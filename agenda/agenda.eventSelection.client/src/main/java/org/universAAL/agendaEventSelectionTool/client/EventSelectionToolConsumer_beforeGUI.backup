package gr.anco.persona.eventSelectionTool.client;

import gr.anco.persona.agenda.ont.Calendar;
import gr.anco.persona.agenda.ont.Event;
import gr.anco.persona.agenda.ont.service.CalendarAgenda;
import gr.anco.persona.eventSelectionTool.ont.EventSelectionTool;
import gr.anco.persona.eventSelectionTool.ont.FilterParams;
import gr.anco.persona.eventSelectionTool.ont.TimeSearchType;
import gr.anco.persona.eventSelectionTool.ont.service.EventSelectionToolService;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import javax.xml.datatype.XMLGregorianCalendar;

import org.osgi.framework.BundleContext;
import org.osgi.service.log.LogService;
import org.persona.middleware.TypeMapper;
import org.persona.middleware.context.ContextEvent;
import org.persona.middleware.context.ContextEventPattern;
import org.persona.middleware.context.ContextSubscriber;
import org.persona.middleware.service.CallStatus;
import org.persona.middleware.service.DefaultServiceCaller;
import org.persona.middleware.service.PropertyPath;
import org.persona.middleware.service.ServiceCaller;
import org.persona.middleware.service.ServiceRequest;
import org.persona.middleware.service.ServiceResponse;
import org.persona.middleware.service.process.ProcessOutput;
import org.persona.ontology.expr.Restriction;


public class EventSelectionToolConsumer extends ContextSubscriber {
	private static final String EVENT_SELECTION_TOOL_SERVER_NAMESPACE = "http://ontology.persona.anco.gr/EventSelectionToolServer.owl#";

	private static final String OUTPUT_EVENT_LIST = EVENT_SELECTION_TOOL_SERVER_NAMESPACE + "eventList";
	private ServiceCaller caller;
	
	/**
	 * return an array of context event patterns, to be used for context event filtering
	 */
	private static ContextEventPattern[] getContextSubscriptionParams() {
		// I am interested in all existing EventSelectionTool. Am I really? -> To be re-considered
		ContextEventPattern cep = new ContextEventPattern();
		cep.addRestriction(Restriction.getAllValuesRestriction(ContextEvent.PROP_RDF_SUBJECT, EventSelectionTool.MY_URI));
		
		return new ContextEventPattern[] {cep};
	}
	
	
	
	//Construct
	
	EventSelectionToolConsumer(BundleContext context) {
		super(context, getContextSubscriptionParams());
		caller = new DefaultServiceCaller(context);
		
		
		XMLGregorianCalendar eventBegin = TypeMapper.getDataTypeFactory().newXMLGregorianCalendar(2008, 12, 31, 23, 59, 59, 0, +2);
		
		FilterParams filterParams = new FilterParams(FilterParams.MY_URI + "Simple1");
		//filterParams.setDTbegin(eventBegin);
		//filterParams.setTimeSearchType(TimeSearchType.allBefore);
		filterParams.setDescription("fes");
		
		String calendarURI = Calendar.MY_URI + "2";
		List calList = new ArrayList(2);
		
		calList.add(new Calendar(calendarURI));
		//calList.add(new Calendar(Calendar.MY_URI + "KostasSocial"));
		
		//get all filter events from specific calendars
		System.out.println("Before first");
		gettingSelectedEvents(filterParams, new ArrayList());
		System.out.println("After first");
		//gettingSelectedEvents(filterParams, calList);
		System.out.println("Before second");
		gettingSelectedLimitedEvents(filterParams, new ArrayList(calList), 0);
		System.out.println("After second");
		//gettingFollowingEvents(new ArrayList(calList), 2);
	}
		
	private void gettingSelectedEvents(FilterParams fp, List calendarList){
		ServiceResponse sr = null;
		//if (calendarList == null || calendarList.size() == 0)
		//	sr = caller.call(requestEvents(fp));
		//else
			sr = caller.call(requestFromCalendarEvents((fp), calendarList));
		
		
		if (sr.getCallStatus() == CallStatus.succeeded)  {
			List getEventList = (List) getReturnValue(sr.getOutputs(), OUTPUT_EVENT_LIST);

			if ((getEventList == null) || (getEventList.size() == 0)) 
				Activator.log.log(LogService.LOG_INFO, "<ESTConsumer>: No event is stored.");
			else
				printEvents(getEventList);

		} else {
			Activator.log.log(LogService.LOG_INFO,
					"<ESTConsumer> Status of Service called: " + sr.getCallStatus());
		}
	}
	
	private void gettingSelectedLimitedEvents(FilterParams fp, List calendarList, int maxEventNo){
		ServiceResponse sr = null;
//		if (calendarList == null || calendarList.size() == 0)
//			sr = caller.call(requestEvents(fp));
//		else
			sr = caller.call(requestFromCalendarLimitedEvents((fp), calendarList, maxEventNo));
		
		
		if (sr.getCallStatus() == CallStatus.succeeded)  {
			List getEventList = (List) getReturnValue(sr.getOutputs(), OUTPUT_EVENT_LIST);

			if ((getEventList == null) || (getEventList.size() == 0)) 
				Activator.log.log(LogService.LOG_INFO, "<ESTConsumer>: No event is stored.");
			else
				printEvents(getEventList);

		} else {
			Activator.log.log(LogService.LOG_INFO,
					"<ESTConsumer> Status of Service called: " + sr.getCallStatus());
		}
	}
	
	private void gettingFollowingEvents(List calendarList, int maxEventNo){
		ServiceResponse sr = null;
		sr = caller.call(requestFollowingEvents(calendarList, maxEventNo));
		
		if (sr.getCallStatus() == CallStatus.succeeded)  {
			List getEventList = (List) getReturnValue(sr.getOutputs(), OUTPUT_EVENT_LIST);

			if ((getEventList == null) || (getEventList.size() == 0)) 
				Activator.log.log(LogService.LOG_INFO, "<ESTConsumer>: No event is stored.");
			else
				printEvents(getEventList);

		} else {
			Activator.log.log(LogService.LOG_INFO,
					"<ESTConsumer> Status of Service called: " + sr.getCallStatus());
		}
	}
		
		
	/**
	 * Creates a {@link ServiceRequest} object in order to use an {@link EventSelectionToolService} service and retrieve
	 * <i>all</i> {@link EventList} which are managed by he server.
	 * @return 				a service request for the specific service 
	 */
	private ServiceRequest requestEvents(FilterParams filterParams) {
		EventSelectionToolService estService = new EventSelectionToolService(null);
		Restriction r1 = Restriction.getFixedValueRestriction(EventSelectionTool.PROP_HAS_FILTER_PARAMS, filterParams);
		
		estService.addInstanceLevelRestriction(r1, 
				new String[] {EventSelectionToolService.PROP_CONTROLS, EventSelectionTool.PROP_HAS_FILTER_PARAMS});

		ServiceRequest listOfRequestedEvents = new ServiceRequest(estService, null); 
		
		PropertyPath ppEvent = new PropertyPath(null, true,
				new String[] {CalendarAgenda.PROP_CONTROLS, Calendar.PROP_HAS_EVENT});
		listOfRequestedEvents.addSimpleOutputBinding(new ProcessOutput(OUTPUT_EVENT_LIST), ppEvent);
				
		return listOfRequestedEvents;
	}
	
	private ServiceRequest requestFromCalendarEvents(FilterParams fp, List calList) {
		ServiceRequest listOfRequestedEvents = new ServiceRequest(new EventSelectionToolService(null), null); 
		PropertyPath ppEvent = new PropertyPath(null, true, 
				new String[] {CalendarAgenda.PROP_CONTROLS, Calendar.PROP_HAS_EVENT});
		PropertyPath ppCalendar = new PropertyPath(null, true,
				new String[] {EventSelectionToolService.PROP_CONTROLS, EventSelectionTool.PROP_HAS_CALENDARS});
		PropertyPath ppFilterParams = new PropertyPath(null, true,
				new String[] {EventSelectionToolService.PROP_CONTROLS, EventSelectionTool.PROP_HAS_FILTER_PARAMS});
		listOfRequestedEvents.addChangeEffect(ppCalendar, calList);
		listOfRequestedEvents.addChangeEffect(ppFilterParams, fp);
		listOfRequestedEvents.addSimpleOutputBinding(new ProcessOutput(OUTPUT_EVENT_LIST), ppEvent);
		
				
		return listOfRequestedEvents;		
	}
	
	private ServiceRequest requestFromCalendarLimitedEvents(FilterParams fp, List calList, int maxEventNo) {
		ServiceRequest listOfRequestedEvents = new ServiceRequest(new EventSelectionToolService(null), null); 
		PropertyPath ppEvent = new PropertyPath(null, true, 
				new String[] {CalendarAgenda.PROP_CONTROLS, Calendar.PROP_HAS_EVENT});
		PropertyPath ppCalendar = new PropertyPath(null, true,
				new String[] {EventSelectionToolService.PROP_CONTROLS, EventSelectionTool.PROP_HAS_CALENDARS});
		PropertyPath ppFilterParams = new PropertyPath(null, true,
				new String[] {EventSelectionToolService.PROP_CONTROLS, EventSelectionTool.PROP_HAS_FILTER_PARAMS});
		PropertyPath ppMaxEventNo = new PropertyPath(null, true,
				new String[] {EventSelectionToolService.PROP_CONTROLS,EventSelectionTool.PROP_MAX_EVENT_NO});
		listOfRequestedEvents.addChangeEffect(ppCalendar, calList);
		listOfRequestedEvents.addChangeEffect(ppFilterParams, fp);
		listOfRequestedEvents.addChangeEffect(ppMaxEventNo, new Integer(maxEventNo));
		listOfRequestedEvents.addSimpleOutputBinding(new ProcessOutput(OUTPUT_EVENT_LIST), ppEvent);
		
				
		return listOfRequestedEvents;		
	}
	
	private ServiceRequest requestFollowingEvents(List calList, int maxEventNo) {
		ServiceRequest listOfRequestedEvents = new ServiceRequest(new EventSelectionToolService(null), null); 
		PropertyPath ppEvent = new PropertyPath(null, true, 
				new String[] {CalendarAgenda.PROP_CONTROLS, Calendar.PROP_HAS_EVENT});
		PropertyPath ppCalendar = new PropertyPath(null, true,
				new String[] {EventSelectionToolService.PROP_CONTROLS, EventSelectionTool.PROP_HAS_CALENDARS});
		PropertyPath ppMaxEventNo = new PropertyPath(null, true,
				new String[] {EventSelectionToolService.PROP_CONTROLS,EventSelectionTool.PROP_MAX_EVENT_NO});
		
		listOfRequestedEvents.addChangeEffect(ppCalendar, calList);
		listOfRequestedEvents.addChangeEffect(ppMaxEventNo, new Integer(maxEventNo));
		listOfRequestedEvents.addSimpleOutputBinding(new ProcessOutput(OUTPUT_EVENT_LIST), ppEvent);
						
		return listOfRequestedEvents;		
	}
	
	private Object getReturnValue(List outputs, String expectedOutput) {
		Object returnValue = null;
		int testCount = 0;
	
		if (outputs == null) {
			Activator.log.log(LogService.LOG_INFO,
					"EventSelectionToolConsumer: No info found!");
		} else 
			for (Iterator i = outputs.iterator(); i.hasNext();) {
			ProcessOutput output = (ProcessOutput) i.next();
			
			if (output.getURI().equals(expectedOutput))
				if (returnValue == null) 
					returnValue = output.getParameterValue();
				else
					Activator.log.log(LogService.LOG_INFO,
							"EventSelectionToolConsumer: redundant return value!");
			else
				Activator.log.log(LogService.LOG_INFO,
						"EventSelectionToolConsumer - output ignored: " + output.getURI());
		}
		
		return returnValue;
	}
	
	
	public void communicationChannelBroken() {
		// TODO Auto-generated method stub
	}
	
	
	public void handleContextEvent(ContextEvent event) {
		Activator.log.log(LogService.LOG_INFO,
				"Received1 context event:\n" +
				"    Subject      = " + event.getSubjectURI()+"\n" +
				"    Subject type = " + event.getSubjectTypeURI()+"\n" +
				"    Predicate    = " + event.getRDFPredicate()+"\n" +
				"    Object       = " + event.getRDFObject());
	}
	
	private void printEvents(List events) {
		Activator.log.log(LogService.LOG_INFO, "Events received& printed out!");
		
		for (Iterator it = events.listIterator(); it.hasNext();) {
			Event e = (Event) it.next();
			Activator.log.log(LogService.LOG_INFO, ">>> Client received event = " + e);
		}	
	}


}
